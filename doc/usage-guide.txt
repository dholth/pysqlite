--------------------
pysqlite usage guide
--------------------

Introduction
============

This Usage Guide is not a tutorial on Python, SQL, or SQLite; rather, it is a
topical presentation of pysqlite's feature set, with example code to
demonstrate basic usage patterns. This guide is meant to be consumed in
conjunction with the Python Database API Specification and the SQLite
documentation.

Python Database API 2.0 Compliance
==================================

Incompatibilities
-----------------

    * No type information in cursor.description

        cursor.description has a tuple with the fields (name, type_code,
        display_size, internal_size, precision, scale, null_ok) for each column
        that a query returns. The DB-API spec requires that at least name and
        type_code are filled, but at the time cursor.description is built,
        pysqlite cannot determine any types, yet. So, the only fields of
        cursor.description that pysqlite fills is the first one for the column
        name. All other fields are set to None.

Unsupported Optional Features
-----------------------------

    * Cursor class
          * nextset method

            This method is not implemented because the database engine does not
            support opening multiple result sets simultaneously with a single
            cursor.

Nominally Supported Optional Features
-------------------------------------

    * Cursor class
          * arraysize attribute

            As required by the spec, the value of this attribute is observed
            with respect to the fetchmany method. However, changing the value
            of this attribute does not make any difference in fetch efficiency
            because the database engine only supports fetching a single row at
            a time.

          * setinputsizes method

            Although this method is present, it does nothing, as allowed by the
            spec.

          * setoutputsize method

            Although this method is present, it does nothing, as allowed by the
            spec.

Extensions and Caveats
----------------------

pysqlite offers a large feature set beyond the minimal requirements of the
Python DB API. Most of these extensions are documented in the section of this
document entitled Native Database Engine Features and Extensions Beyond the
Python DB API.

    * connect function

        The parameter database refers to the database file for the SQLite
        database. It's a normal filesystem path and you can use absolute or
        relative path names.

        The connect function supports the following optional keyword arguments
        in addition to those required by the spec:

        * timeout - When a database is accessed by multiple connections, and

          one of the processes modifies the database, the SQLite database is
          locked until that transaction is committed. The timeout parameter
          specifies how long the connection should wait for the lock to go away
          until raising an exception. The default for the timeout parameter is
          5.0 (five seconds).

          Example::

            sqlite.connect(database="mydb", timeout=10.0)

        * autocommit - Some users don't want to work with transactions, or
          want to write a layer on top of pysqlite that implementes transaction
          management differently than pysqlite. With autocommit=True, pysqlite
          does not issue BEGIN statements automatically any more. Note that you
          can toggle the autocommit attribute of connections also.

          Example::

            sqlite.connect("mydb", autocommit=True)

        * prepareProtocol - SQLite natively supports only the types TEXT (str
          and unicode), INTEGER (int and long), FLOAT (float), BLOB (buffer)
          and NULL (None). The names in brackets are the corresponding Python
          types.

          For using other Python types with SQLite, you need to add support to
          them using pysqlite. You can do that by giving your custom Python
          type a __conform__ method with this signature::

            def __conform__(self, protocol):
                ...

          The Python type then can check if protocol is an instance of
          pysqlite.dbapi2.PrepareProtocol and adapt itself to one of SQLite's
          supported Python types: str, unicode, int, long, float, buffer. Or
          return None if it cannot adapt itself.

          Normally, it's more practical to extend pysqlite's PrepareProtocol
          instead so it supports your type.

          For example if you wanted to add support for the standard Python
          datetime.datetime type to pysqlite, you could do it like this::

            import pysqlite2.dbapi2 as sqlite
            import datetime, time

            class MyProtocol:
                def __adapt__(self, val):
                    if type(val) is datetime.datetime:
                        return time.mktime(val.timetuple())

            con = sqlite.connect("mydb", prepareProtocol=MyProtocol())
            cur = con.cursor()
            cur.execute("insert into mytable(ts) values (?)", (datetime.datetime.now(),))

        * detect_types - SQLite natively supports only the types TEXT,
          INTEGER, FLOAT, BLOB and NULL. If you want to use other types, like
          date/time related ones, you have to add support for them yourself.
          The detect_types parameter and the converters attribute of
          connections allow you to easily do that.

          detect_types defaults to 0 (i. e. off, no type detection), you can
          set it to any combination of sqlite.PARSE_DECLTYPES and
          sqlite.PARSE_COLNAMES to turn type detection on.

            * sqlite.PARSE_DECLTYPES - This makes pysqlite parse the declared
              type for each column it returns. It will parse out the first word
              of the declared type, i. e. for "integer primary key", it will
              parse out "integer". Then for that column, it will look into the
              converters property of the connection (a dictionary that you can
              modify at will) and use the converter function registered for
              that type there.

              Example::

                class MyProtocol:
                    def __adapt__(self, val):
                        if type(val) is datetime.datetime:
                            return time.mktime(val.timetuple())

                def dt_from_float(val):
                    return datetime.datetime.fromtimestamp(float(val))

                con = sqlite.connect(":memory:", prepareProtocol=MyProtocol(), detect_types=sqlite.PARSE_DECLTYPES)
                con.converters["datetime"] = dt_from_float
                cur = con.cursor()
                cur.execute("create table test(ts datetime)")
                cur.execute("insert into test(ts) values (?)", (datetime.datetime.now(),))
                cur.execute("select ts from test")
                dt = cur.fetchone()[0]
                print dt, type(dt)
                dt = cur.fetchone()[0]
                print dt, type(dt)

            * sqlite.PARSE_COLNAMES - This makes pysqlite parse the column name
              for each column it returns. It will look for a string formed
              [mytype] in there, and then decide that 'mytype' is the type of
              the column. It will try to find an entry of 'mytype' in the
              converters dictionary and then use the converter function found
              there to return the value. The column name found in
              cursor.description is only the first word of the column name, i.
              e. if you use something like 'as "x [datetime]"' in your SQL,
              then pysqlite will parse out everything until the first blank for
              the column name: the column name would simply be "x".

              Example::

                same as above, but:

                cur = con.cursor()
                cur.execute('select ? as "x [datetime]"', (datetime.datetime.now(),))
                dt = cur.fetchone()[0]
                print dt, type(dt)

        * check_same_thread - SQLite connections/cursors can only safely be
          used in the same thread they were created in. pysqlite checks for
          this each time it would do a call to the SQLite engine. If you are
          confident that you are ensuring safety otherwise, you can disable
          that checks by setting check_same_thread to False.

        * factory - By default, pysqlite uses the Connection class for the

          connect call. You can, however, subclass the Connection class and
          make .connect() use your class instead by providing your class for
          the factory parameter.

            Example::

                from pysqlite2 import dbapi2 as sqlite

                class CountCursorsConnection(sqlite.Connection):
                    def __init__(self, *args, **kwargs):
                        sqlite.Connection.__init__(self, *args, **kwargs)
                        self.numcursors = 0

                    def cursor(self, *args, **kwargs):
                        self.numcursors += 1
                        return sqlite.Connection.cursor(self, *args, **kwargs)

                con = sqlite.connect(":memory:", factory=CountCursorsConnection)
                cur1 = con.cursor()
                cur2 = con.cursor()
                print con.numcursors

    * Connection class
        * autocommit attribute (read-write)
          Some users don't want to work with transactions, or want to write a
          layer on top of pysqlite that implementes transaction management
          differently than pysqlite. With autocommit=True, pysqlite does not
          issue BEGIN statements automatically any more. Note that you set the
          autocommit value at connection creation time using the autocommit
          parameter to connect also.

        * converters attribute (read-write)
          This dictionary maps type names to converter functions, it's empty by
          default, and you can replace it with your own dictionary or modify
          it.


        * create_function method - Using pysqlite, you can define user-defined
          functions for SQL. The create_function method has this signature::

            def create_function(self, name, numparams, func)

            * name - the name of your function in SQL

            * numparams - the number of paramters your function accepts, -1 if
              it accepts any number of parameters

            * func - the Python function

           The function can return any of pysqlite's supported SQLite types:
           unicode, str, int, long, float, buffer and None.  The function
           should never raise an exception.

            Example::

                from pysqlite2 import dbapi2 as sqlite
                import md5

                def md5sum(t):
                    return md5.md5(t).hexdigest()

                con = sqlite.connect(":memory:")
                con.create_function("md5", 1, md5sum)
                cur = con.cursor()
                cur.execute("select md5(?)", ("foo",))
                print cur.fetchone()[0]

        * create_aggregate method - Using pysqlite, you can define user-defined
          aggregates for SQL. The create_aggregate method has this signature::

            def create_aggregate(self, name, numparams, aggregate_class)

          The aggregate class must implement a "step" method, which accepts the
          number of parameters defined in create_aggregate, and a finalize
          method which will return the final result of the aggregate.

          Example::

            from pysqlite2 import dbapi2 as sqlite

            class MySum:
                def __init__(self):
                    self.count = 0

                def step(self, value):
                    self.count += value

                def finalize(self):
                    return self.count

            con = sqlite.connect(":memory:")
            con.create_aggregate("mysum", 1, MySum)
            cur = con.cursor()
            cur.execute("create table test(i)")
            cur.execute("insert into test(i) values (1)")
            cur.execute("insert into test(i) values (2)")
            cur.execute("select mysum(i) from test")
            print cur.fetchone()[0]

        * cursor method - The cursor method accepts a single parameter: the
          cursor class. There, you can pass a class that extends the standard
          Cursor class and adapt it to your needs. For a useful example, look
          at the example for the row_factory attribute of cursors.

    * Cursor class
        * rowcount attribute

            Although pysqlite's Cursors implement this attribute, the database
            engine's own support for the determination of "rows affected"/"rows
            selected" is quirky.

            For SELECT statements, rowcount is always None because pysqlite
            cannot determine the number of rows a query produced until all rows
            were fetched.

            For DELETE statements, SQLite reports rowcount as 0 if you make a
            "DELETE FROM table" without any condition.

            For executemany statements, pysqlite sums up the number of
            modifications into rowcount.

            As required by the Python DB API Spec, the rowcount attribute "is
            -1 in case no executeXX() has been performed on the cursor or the
            rowcount of the last operation is not determinable by the
            interface".

        * row_factory attribute (read-write)

            You can change this attribute to a callable that accepts the cursor
            and the original row as tuple and will return the real result row.
            This way, you can implement more advanced ways of returning
            results, like ones that can also access columns by name.

            Example::

                from pysqlite2 import dbapi2 as sqlite

                def dict_factory(cursor, row):
                    d = {}
                    for idx, col in enumerate(cursor.description):
                        d[col[0]] = row[idx]
                    return d

                class DictCursor(sqlite.Cursor):
                    def __init__(self, *args, **kwargs):
                        sqlite.Cursor.__init__(self, *args, **kwargs)
                        self.row_factory = lambda row: dict_factory(self, row)


                con = sqlite.connect(":memory:")
                cur = con.cursor(factory=DictCursor)
                cur.execute("select 1 as a")
                print cur.fetchone()["a"]


Brief Tutorial
==============

This brief tutorial aims to get the reader started by demonstrating elementary
usage of pysqlite. It is not a comprehensive Python Database API tutorial, nor
is it comprehensive in its coverage of anything else.

Connecting to a Database
------------------------

    **Example 1**

    Connecting to a database file *mydb*::

        from pysqlite2 import dbapi2 as sqlite

        con = sqlite.connect("mydb")


    **Example 2**

    Creating an in-memory database::

        from pysqlite2 import dbapi2 as sqlite

        con = sqlite.connect(":memory:")


Executing SQL statements
------------------------

For this section, we have a database *mydb* defined and populated by the
following SQL code::

    create table person (
      first,
      age
    );

    insert into people (firstname, age) values ('John', 52);
    insert into people (firstname, age) values ('Susan', 47);


*Example 1*

This example shows the simplest way to print the entire contents of the ``people`` table::

    from pysqlite2 import dbapi2 as sqlite
    con = sqlite.connect("mydb")
    cur = con.cursor()
    cur.execute("select * from person order by age")
    print cur.fetchall()

Sample output::

    [(u'Susan', None, 47), (u'John', None, 52)]

*Example 2*

Here's another trivial example that demonstrates various ways of fetching a
single row at a time from a SELECT-cursor::

    from pysqlite2 import dbapi2 as sqlite

    con = sqlite.connect("mydb")

    cur = con.cursor()
    SELECT = "select firstname, age from person order by age, firstname"

    # 1. Iterate over the rows available from the cursor, unpacking the
    # resulting sequences to yield their elements (firstname, age):
    cur.execute(SELECT)
    for (firstname, age) in cur:
        print '%s is %d years old.' % (firstname, age)

    # 2. Equivalently:
    cur.execute(SELECT)
    for row in cur:
        print '%s is %d years old.' % (row[0], row[1])

Sample output::

    Susan is 47 years old.
    John is 52 years old.
    Susan is 47 years old.
    John is 52 years old.


